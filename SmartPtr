#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
#include<vector>
#include<malloc.h>
#include<mutex>
#include<thread>
#include<malloc.h>
// C++库中的智能指针都定义在memory这个头文件中
#include<memory>

using namespace  std;

//template<class T>
//class SmartPtr {
//public:
//	SmartPtr(T* ptr = nullptr)
//		: _ptr(ptr)
//	{}
//	~SmartPtr()
//	{
//		if (_ptr)
//			delete _ptr;
//	}
//	T* _ptr;
//};
//void MergeSort(int* a, int n)
//{
//	int* tmp = (int*)malloc(sizeof(int)*n);
//	// 讲tmp指针委托给了sp对象，用时老师的话说给tmp指针找了一个可怕的女朋友！天天管着你，直到你go die 
//		SmartPtr<int> sp(tmp);
//	// _MergeSort(a, 0, n - 1, tmp);
//	// 这里假设处理了一些其他逻辑
//	vector<int> v(1000000000, 10);
//	// ...
//}
//int main()
//{
//	try {
//		int a[5] = { 4, 5, 2, 3, 1 };
//		MergeSort(a, 5);
//	}
//	catch (const exception& e)
//	{
//		cout << e.what() << endl;
//	}
//	return 0;
//}

#if 0

//智能指针：1.实现RAII思想，2.实现指针的操作
template<class T>
class SmartPtr {
public:
	SmartPtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~SmartPtr()
	{
		if (_ptr)
		{
			delete _ptr;
			cout << "delete" << endl;
			_ptr = nullptr;
		}
	}

	//实现指针功能：解引用 ->

	T& operator*()
	{
		return *_ptr;
	}
		
	T* operator->()
	{
		return _ptr;
	}

private:
	T* _ptr;
};

class A
{
public:
	int _a = 1;
	int _b = 2;
	int _c = 3;
	~A()
	{
		cout << "~A()" << endl;
	}
};


int main()
{
	/*
	//常规的指针
	int* pi = new int(2);
	cout << *pi << endl;
	*pi = 3;
	cout << *pi << endl;
	//普通指针malloc后需要手动释放
	delete pi;
	//智能指针
	cout << "SmartPtr:" << endl;
	SmartPtr<int> sp(new int(10));
	cout << *sp << endl;
	*sp = 20;
	cout << *sp << endl;
	//智能指针编译器会在指针对象使用完成后，进行自动调用析构函数进行释放。
	*/

	/*
	A* pa = new A();
	pa->_a = 10;
	pa->_b = 20;

	SmartPtr<A> sp2(new A());
	//sp2->_a = 10;
	(*sp2)._a = 10;
	sp2.operator->()->_b = 100;
	cout << sp2->_a << endl;
	cout << sp2->_b << endl;
	*/

	/*
	//多个智能指针对象管理同一份资源，仅被释放一次。
	//一般禁止使用
	auto_ptr<A>sp3(new A());//库里的智能指针
	sp3->_a = 20;
	cout << sp3->_a << endl;

	auto_ptr<A>copy(sp3);//假如两个auto_ptr智能指针同时管理一份资源，就会造成资源二次释放。
	copy->_a = 100;

	auto_ptr<A>copy2(copy);
	copy2->_b = 1;
	*/

	/*
	//使用自己定义的智能指针多次释放
	SmartPtr<A>sp3(new A());
	sp3->_a = 20;
	cout << sp3->_a << endl;
	SmartPtr<A> copy (sp3);//假如多个个我们自己实现智能指针同时管理一份资源，就会造成资源二次释放。
	copy->_a = 100;
	SmartPtr<A> copy2 (copy);
	copy2->_b = 1;
	*/

	auto_ptr<A>sp3(new A());//库里的智能指针
	sp3->_a = 20;
	cout << sp3->_a << endl;

	auto_ptr<A>copy(sp3);//这里发生一次拷贝，顺便将资源的管理权交给新的对象，它不会再拥有管理资源的能力
	
	//sp3已经完成对资源管理权的转移，因此无法访问到_a成员，sp3指针被悬空，因此在这里程序会崩溃，空指针无法解引用。
	//指针悬空
	//sp3->_a = 1;

	copy->_a = 100;
	auto_ptr<A>copy2(copy);
	//管理权转移，指针悬空，因此不能解引用访问。
	//copy->_b = 1;

	copy2->_b = 1;
	//system("pause");
	return 0;
}
#endif




/*

//测试 系统中auto_ptr智能指针，在对同一块空间被多个对象使用而造成程序奔溃问题
class A
{
public:
	int _a = 1;
	int _b = 2;
	int _c = 3;
	~A()
	{
		cout << "~A()" << endl;
	}
};

int main()
{
	auto_ptr<A>sp3(new A());//库里的智能指针
	sp3->_a = 20;
	cout << sp3->_a << endl;

	auto_ptr<A>copy(sp3);//这里发生一次拷贝，顺便将资源的管理权交给新的对象，它不会再拥有管理资源的能力

	//sp3已经完成对资源管理权的转移，因此无法访问到_a成员，sp3指针被悬空，因此在这里程序会崩溃，空指针无法解引用。
	//指针悬空
	//sp3->_a = 1;

	copy->_a = 100;
	auto_ptr<A>copy2(copy);
	//管理权转移，指针悬空，因此copy不能进行解引用访问。
	//copy->_b = 1;

	copy2->_b = 1;
	//system("pause");
	return 0;
}

*/


/*
//模拟实现auto_ptr智能指针： 解决之前的auto_ptr存在二次释放问题
template<class T>
class AutoPtr {
public:
	AutoPtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~AutoPtr()
	{
		if (_ptr)
		{
			delete _ptr;
			cout << "delete" << endl;
			_ptr = nullptr;
		}
	}

	// 一旦发生拷贝，就将ap中资源转移到当前对象中，然后另ap与其所管理资源断开联系，
	// 这样就解决了一块空间被多个对象使用而造成程序奔溃问题
	//浅拷贝，指针只是管理资源，不拥有资源
	//管理权转移 拷贝构造
	AutoPtr(AutoPtr<T>& ap)
		:_ptr(ap._ptr)
	{
		ap._ptr = nullptr;
	}

	//赋值运算符重载
	AutoPtr<T>& operator=(AutoPtr<T>& ap)
	{
		// 检测是否为自己给自己赋值
		if (this != ap)
		{
			// 释放当前对象中资源
			if (_ptr)
				delete _ptr;
			//管理权转移
			// 转移ap中资源到当前对象中
			_ptr = ap._ptr;
			ap._ptr = nullptr;	
		}
		return *this;
	}

	//实现指针功能：解引用 ->

	T& operator*()
	{
		return *_ptr;
	}

	T* operator->()
	{
		return _ptr;
	}

private:
	T* _ptr;
};

class A
{
public:
	int _a = 1;
	int _b = 2;
	int _c = 3;
	~A()
	{
		cout << "~A()" << endl;
	}
};

int main()
{
	AutoPtr<A> sp4(new A());
	sp4->_a = 10;

	AutoPtr<A> copy3(sp4);
	copy3->_a = 100;

	AutoPtr<A> copy4(copy3);
	copy4->_b = 1;
	//只会调用一次析构 一次 delete
	//system("pause");
	return 0;
}

*/

#if 0
//unique_Ptr测试与模拟实现


//模拟实现Unique_Ptr:只需要禁止掉拷贝构造和赋值运算符重载函数
template<class T>
class UniquePtr {
public:
	UniquePtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~UniquePtr()
	{
		if (_ptr)
		{
			delete _ptr;
			cout << "delete" << endl;
			_ptr = nullptr;
		}
	}

	//禁止掉拷贝构造和赋值运算符重载函数:有两种方法 {1}使用C++11语法delete  {2}将两个函数定义为私有，只声明不实现

	//禁止拷贝构造 
	//C++11语法 声明成delete函数
	UniquePtr(UniquePtr<T>& ap) = delete;
	//C++11语法
	//禁止赋值运算符重载 声明成delete函数
	UniquePtr<T>& operator=(UniquePtr<T>& ap) = delete;

	//实现指针功能：解引用 还有  ->

	T& operator*()
	{
		return *_ptr;
	}

	T* operator->()
	{
		return _ptr;
	}

private:

	//定义成私有，只声明不实现
	//防拷贝构造 
	UniquePtr(UniquePtr<T>& ap);
	//防赋值运算符重载
	UniquePtr<T>& operator=(UniquePtr<T>& ap);

	T* _ptr;
};


class A
{
public:
	int _a = 1;
	int _b = 2;
	int _c = 3;
	~A()
	{
		cout << "~A()" << endl;
	}
};

int main()
{
	unique_ptr<A> up(new A());
	up->_a = 10;
	/*
	unique_ptr<A> up2(new A());
	//使用库里面unique_ptr：它禁止相互间的赋值行为，防赋值
	up2 = up;
	//使用库里面unique_ptr：它禁止相互间的拷贝行为,防拷贝
	unique_ptr<A> copy(up);
	*/

	/*
	//使用自己实现的UniquePtr测试拷贝和赋值操作
	UniquePtr<A> up3(new A());
	UniquePtr<A> copy2(up3);
	UniquePtr<A> up4(new A());
	up4 = up3;
	*/

	//system("pause");
    return 0;
}
#endif



//share_ptr使用测试,与模拟实现
#if 0
class A
{
public:
	int _a = 1;
	int _b = 2;
	int _c = 3;
	~A()
	{
		cout << "~A()" << endl;
	}
};
int main()
{
	shared_ptr<A> sp(new A());
	//查看引用计数，看当前资源被几个指针管理
	cout << sp.use_count() << endl;//1
	//可以拷贝
	shared_ptr<A> cope(sp);
	cout << cope.use_count() << endl;//2
	//可以赋值
	shared_ptr<A> sp2(new A());
	cout << sp2.use_count() << endl;//1
	sp2 = sp;
	cout << sp2.use_count() << endl;//3
	//程序结束释放两次delte
	system("pause");
	return 0;
}
#endif
/*
//shared_ptr模拟实现:释放时采用引用计数方法
template<class T>
class SharedPtr{
public:
	SharedPtr(T* ptr)
		:_ptr(ptr)
		, _pcount(new int(1))
		, _mtx(new mutex())
	{}

	SharedPtr(SharedPtr<T>& sp)
		:_ptr(sp._ptr)
		, _pcount(sp._pcount)
		, _mtx(sp._mtx)
	{
		_mtx->lock();
		++(*_pcount);
		_mtx->unlock();
	}
	
	SharedPtr<T>& operator=(SharedPtr<T>& sp)
	{
		//if (this != sp)
		if (_ptr != sp._ptr)
		{
			_mtx->lock();
			--(*_pcount);
			_mtx->unlock();
			if (*_pcount == 0)
			{
				delete _pcount;
				delete _ptr;
			}
			_ptr = sp._ptr;
			_pcount = sp._pcount;

			_mtx->lock();
			++(*_pcount);
			_mtx->unlock();
		}
		return *this;
	}

	~SharedPtr()
	{
		_mtx->lock();
		--(*_pcount);
		_mtx->unlock();
		if (*_pcount == 0)
		{
			if (_ptr)
			{
				delete _ptr;
				delete _pcount;
				cout << "delete _ptr" << endl;
				_ptr = nullptr;
				_pcount = nullptr;
			}
		}
	}

	//实现指针功能：解引用 还有  ->
	T& operator*()
	{
		return *_ptr;
	}

	T* operator->()
	{
		return _ptr;
	}


	int useCount()
	{
		return *_pcount;
	}

private:
	T* _ptr;

	int *_pcount;
	//不能给成静态的  不能使用一个引用计数表示所有资源被引用的数量，应该每一个资源都拥有自己的引用计数
	//static int _count;

	mutex* _mtx;//保证原子性操作
};

//template<class T>
//int SharedPtr<T>::_count = 0;


int main()
{
	SharedPtr<int> sp(new int(1));
	SharedPtr<int> sp2(new int(2));
	cout << sp.useCount() << endl;//1
	cout << sp2.useCount() << endl;//1
	SharedPtr<int> copy(sp);
	cout << sp.useCount() << endl;//2
	cout << copy.useCount() << endl;//2

	sp2 = sp;
	cout << sp.useCount() << endl;//3
	cout << sp2.useCount() << endl;//3
	copy = sp;
	cout << copy.useCount() << endl;//3
	cout << sp.useCount() << endl;//3
	
	system("pause");
	return 0;
}
*/


#if 0

template<class T>
class SharedPtr{
public:
	SharedPtr(T* ptr)
		:_ptr(ptr)
		, _pcount(new int(1))
		, _mtx(new mutex())
	{}

	SharedPtr(SharedPtr<T>& sp)
		:_ptr(sp._ptr)
		, _pcount(sp._pcount)
		, _mtx(sp._mtx)
	{
		/*_mtx->lock();
		++(*_pcount);
		_mtx->unlock();*/
		addRef();
	}

	SharedPtr<T>& operator=(SharedPtr<T>& sp)
	{
		//if (this != sp)
		if (_ptr != sp._ptr)
		{
			/*_mtx->lock();
			--(*_pcount);
			_mtx->unlock();*/
			if (subRef() == 0)
			{
				delete _pcount;
				delete _ptr;
			}
			_ptr = sp._ptr;
			_pcount = sp._pcount;

			/*_mtx->lock();
			++(*_pcount);
			_mtx->unlock();*/
			addRef();
		}
		return *this;
	}

	~SharedPtr()
	{
		
		/*_mtx->lock();
		--(*_pcount);
		_mtx->unlock();*/
		if (subRef() == 0)
		{
			if (_ptr)
			{
				delete _ptr;
				delete _pcount;
				cout << "delete _ptr" << endl;
				_ptr = nullptr;
				_pcount = nullptr;
			}
		}
	}

	//实现指针功能：解引用 还有  ->
	T& operator*()
	{
		return *_ptr;
	}

	T* operator->()
	{
		return _ptr;
	}


	int useCount()
	{
		return *_pcount;
	}

	int addRef()
	{
		_mtx->lock();
		++(*_pcount);
		_mtx->unlock();
		return *_pcount;
	}

	int subRef()
	{
		_mtx->lock();
		--(*_pcount);
		_mtx->unlock();
		return *_pcount;
	}

private:
	T* _ptr;

	int *_pcount;
	//不能给成静态的  不能使用一个引用计数表示所有资源被引用的数量，应该每一个资源都拥有自己的引用计数
	//static int _count;

	mutex* _mtx;//保证原子性操作
};


#include<thread>
mutex mtx;
//使用自己定义的 SharedPtr
void fun(SharedPtr<int>& sp, int n)
{
	for (int i = 1; i <= n; ++i)
	{
		mtx.lock();
		++(*sp);
		mtx.unlock();
		SharedPtr<int> copy(sp);
	}
}
void test1()
{
	int n = 10000;
	SharedPtr<int> sp(new int(0));
	thread t1(fun, sp, n);
	thread t2(fun, sp, n);
	t1.join();
	t2.join();
	cout << *sp << endl;//不确定
	cout << sp.useCount() << endl;//1
}
//使用库里面的 shared_ptr
void fun2(shared_ptr<int>sp, int n)
{
	for (int i = 0; i < n; ++i)
	{
		mtx.lock();
		++(*sp);
		mtx.unlock();
		shared_ptr<int> copy(sp);
	}
}


void test2()
{
	int n = 10000;
	shared_ptr<int> sp(new int(0));
	thread t1(fun2, sp, n);
	thread t2(fun2, sp, n);
	t1.join();
	t2.join();
	cout << *sp << endl;//不确定
	cout << sp.use_count() << endl;//1
}

int main()
{
	test1();
	//test2();
	system("pause");
	return 0;
}

#endif

#if 0
//循环引用 造成无法释放结点
template <class T>
class ListNode
{
public:
	shared_ptr<ListNode<T>> _prev;
	shared_ptr<ListNode<T>> _next;
	~ListNode()
	{ 
		cout << "~ListNode()" << endl; 
	}
};

void test3()
{
	shared_ptr<ListNode<int>> sp(new ListNode<int>());
	shared_ptr<ListNode<int>> sp2(new ListNode<int>());
	cout << sp.use_count() << endl;//1
	cout << sp2.use_count() << endl;//1
	sp->_next = sp2;
	sp2->_prev = sp;
	cout << sp.use_count() << endl;//2
	cout << sp2.use_count() << endl;//2

	//无法释放空间，没调用析构函数
}

int main()
{
	test3();
	system("pause");
	return 0;
}

#endif


#if 0
//解决循环引用方法
template <class T>
class ListNode
{
public:
	//weak_ptr:不会管理资源，也不会修改引用计数
	weak_ptr<ListNode<T>> _prev;
	weak_ptr<ListNode<T>> _next;
	~ListNode()
	{
		cout << "~ListNode()" << endl;
	}
};

void test3()
{
	shared_ptr<ListNode<int>> sp(new ListNode<int>());
	shared_ptr<ListNode<int>> sp2(new ListNode<int>());
	cout << sp.use_count() << endl;//1
	cout << sp2.use_count() << endl;//1
	sp->_next = sp2;
	sp2->_prev = sp;
	cout << sp.use_count() << endl;//1
	cout << sp2.use_count() << endl;//1
	
	//weak_ptr: 不可以单独使用，需要借助shared_ptr进行初始化。
	weak_ptr<int> wp(new int(2));
}

int main()
{
	test3();
	system("pause");
	return 0;
}
#endif



#if 0

//仿函数的删除器,定制删除器
class B
{
public:
	~B()
	{
		cout << "~B()" << endl;
	}
};

template <class T>
class DeleteArray
{
public:
	//仿函数 ： 重载括号运算符函数
	void operator() (T* ptr)
	{
		cout << "delete[]" << ptr << endl;
		delete[] ptr;
	}
};

template <class T>
class FreeDelete
{
public:
	//仿函数 ： 重载括号运算符函数
	void operator() (T* ptr)
	{
		cout << "free:" << ptr << endl;
		free(ptr);
	}
};


void test4()
{
	shared_ptr<int> sp(new int[10], DeleteArray<int>());
	shared_ptr<int> sp2((int*)malloc(100), FreeDelete<int>());

	shared_ptr<B> sp3(new B[10], DeleteArray<B>());
	shared_ptr<B> sp4((B*)malloc(100),FreeDelete<B>());
}

int main()
{
	test4();
	system("pause");
	return 0;
}

#endif



//守卫锁 也是利用RAII思想,利用对象声明周期管理锁的生命周期：构造加锁，析构解锁。
template<class Mtx>
class LockGuard
{
public:
	LockGuard(Mtx& mtx)
		:_mtx(mtx)
	{
		_mtx.lock();
	}
	~LockGuard()
	{
		cout << "~LockGuard()" << endl;
		_mtx.unlock();
	}
	//防拷贝，   如果可以拷贝的话，导致多个对象同时解锁，而一个锁不能被解锁多次，因此需要防拷贝
	LockGuard(const LockGuard<Mtx>& lg) = delete;

private:
	// 注意这里必须使用引用，不支持拷贝，否则锁的就不是一个互斥量对象
	Mtx& _mtx;
};

mutex mtx;
void fun()
{
	int i;
	cin >> i;
	//mtx.lock();
	LockGuard<mutex> lg(mtx);
	if (i == 9)
	{
		return;
		cout << i << endl;
	}
	//mtx.unlock();
	
}

int main()
{
	thread t1(fun);
	thread t2(fun);
	t1.join();
	t2.join();
	system("pause");
	return 0;
}
